
# Option 2

# Context & Objectives

You are an AI engineer at a growing e-commerce startup that receives hundreds of product inquiries daily through their chat platform. Customers ask about product prices, availability, specifications, and want to place orders, but the current system requires them to navigate multiple pages and forms, leading to cart abandonment and lost sales. Leadership has tasked you with building an intelligent delivery chatbot that can answer product questions instantly using RAG and autonomously process orders through natural conversation, eliminating friction in the customer journey.

The system must intelligently switch between information retrieval and order processing modes, extract all order details from conversational context without requiring forms, and persist orders reliably to a database, all while using modern AI orchestration patterns (Function Calling, Pydantic validation) that ensure maintainability and production readiness.

## Objectives (what you will deliver and why it matters):

1. Build a dual-agent conversational system where a RAG Agent retrieves product information from a Vector Store (≥30 products with prices, descriptions, stock status) and autonomously hands off to an Order Agent when purchase intent is detected. This solves the real-world problem of handling both pre-purchase questions and checkout in a single conversational flow.
2. Implement autonomous agent orchestration using OpenAI Function Calling with properly defined tools (search_products, create_order) that the LLM selects based purely on conversation context, no manual keyword routing. This demonstrates production-grade AI engineering using industry-standard patterns.
3. Extract complete order details from multi-turn chat history without re-asking the user (product, quantity, price, customer info) and validate them using Pydantic models before database persistence. This creates a friction-free ordering experience while maintaining data integrity.
4. Persist orders to a SQL or structured database with proper schema, unique order IDs, and CRUD operations that survive program restarts. This ensures orders aren't lost and can be retrieved for confirmation and tracking.
5. Document all technical decisions explaining your RAG configuration, Function Calling strategy, agent handoff mechanism, and database choice. This demonstrates engineering judgment and prepares the system for team handoff and future maintenance.

**Why this matters:** Conversational commerce is transforming online shopping. Building a system that combines RAG retrieval, autonomous multi-agent orchestration, function calling, and structured data validation mirrors real production requirements at companies like Shopify, Amazon, and emerging AI-native e-commerce platforms. This capstone integrates everything from Modules 1-4: prompt engineering, RAG architecture, multi-agent systems, and production deployment patterns.

# Assignment

Create a delivery chatbot that features an RAG Agent accessing a Vector Store database to answer client questions regarding product prices. A second agent then takes over, and if the user confirms the order, it autonomously persists the order in an SQL or plain text database. This agent must be able to delegate tasks autonomously using a tool (such as Function Calling for GPT) and must make its decisions based solely on the user-system chat history. This must pass structured inputs to the database agent via Pydantic.

# Project Deliverables and Submission Requirements

Submit via a public Git repository link of the repository. Ensure the repository is self-contained and runnable.

## Expected repository structure

| Deliverable                        | Filename / Format                                         | Minimum Content                                                                                                                                                                                                                                                                                                                                                                                                   |
| ---------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Product database                   | data/products.txt or data/products.json or data/products/ | ≥30 product documents with: product_id, name, description, price, category, stock_status. Can be single file (JSON/CSV) or multiple text files. Must be substantial enough for meaningful RAG retrieval.                                                                                                                                                                                                         |
| Vector Store setup                 | src/initialize_vector_store.py or notebook section        | Code that: (1) loads product documents, (2) chunks/processes them, (3) generates embeddings (OpenAI text-embedding-3-small/large OR Sentence-Transformers), (4) stores in vector database (Chroma/FAISS/Pinecone/Weaviate), (5) saves for retrieval. Must be runnable.                                                                                                                                            |
| Main chatbot application           | src/chatbot.py or app/main.py or chatbot.ipynb            | Complete implementation with: (1) RAG Agent for product queries with vector retrieval, (2) Order Agent with autonomous handoff logic, (3) Function Calling setup with ≥2 tools properly defined, (4) Chat history management, (5) Multi-turn conversation loop, (6) Order extraction from chat context, (7) Database persistence.                                                                                |
| Pydantic models                    | src/models.py or defined in main file                     | e.g. Product and OrderModel with: Field constraints (gt=0 for prices/quantities, min_length for strings), type hints, custom validators for business logic, all required fields for database persistence.                                                                                                                                                                                                         |
| Database schema & operations       | src/database.py or db/schema.sql                          | SQL schema (CREATE TABLE with proper types) OR JSON/text structure documentation. CRUD functions: create_order(), get_order_by_id(). Parameterized queries (if SQL) to prevent injection.                                                                                                                                                                                                                         |
| README                             | README.md                                                 | Setup: Python version, install command, API keys setup (OPENAI_API_KEY). Architecture: Diagram or description of two-agent system with handoff flow. Usage: How to initialize vector store, how to run chatbot. Database: Schema explanation and how to view saved orders. Technical Decisions: Why RAG for products (100+ words), why Function Calling, how agent handoff works, database choice rationale, etc. |
| Dependencies, Environment template | requirements.txt, .env.example                            | Minimum packages: openai, pydantic, langchain (if used), vector store library (chromadb/faiss-cpu/pinecone-client), sqlalchemy (if SQL), python-dotenv. All with version pins. Template showing: OPENAI_API_KEY=your-key-here, DATABASE_PATH=./orders.db, VECTOR_STORE_PATH=./vector_store, model configuration variables.                                                                                        |
| Test scenarios                     | tests/test_chatbot.py or examples/test_conversations.md   | Test conversation flows with expected outcomes: (1) Product price query, (2) Multi-turn product discussion, (3) Order confirmation with extraction, (4) Ambiguous query handling, (5) Invalid order rejection. Can be automated tests OR documented manual test cases.                                                                                                                                            |

---

# Evaluation Rubric

| Criterion                                                   | Excellent                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Satisfactory                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Incomplete/Unsatisfactory                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ----------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. FUNCTIONALITY & CORE REQUIREMENTS                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 1.1 RAG Agent - Product Information Retrieval               | - RAG Agent successfully answers product price queries using Vector Store- Vector Store contains > 30 product documents/chunks with: product_id, name, description, price, stock_status- Retrieval returns 2-5 relevant product chunks per query (k-NN or ANN search)- Answers include specific prices and details from retrieved documents (not hallucinated)- Test with 5+ queries across different product categories: > 4 queries retrieve correct products with accurate prices- Uses embeddings: OpenAI text-embedding-3-small/large OR Sentence-Transformers- Vector Store implemented with Chroma, FAISS, Pinecone, or Weaviate- Agent responses are natural and conversational: "The iPhone 15 Pro is priced at $999 and we have it in stock"- Handles product variations: "Which laptop?" when multiple laptops exist                                                                                                                                                                                                                                                                                                  | - RAG Agent retrieves product information from Vector Store- Vector Store contains > 20 product documents with name, price information- Retrieves 1-5 relevant chunks per query- Answers include prices from documents (mostly accurate, <20% errors)- Test with 3+ queries: >2 queries return correct products and prices- Uses embeddings for similarity search- Vector Store setup visible and functional in code- Basic conversational responses (may be slightly robotic)          | - Agent doesn't use Vector Store (hardcoded product list OR direct LLM without retrieval)- Vector Store has&lt;20 products OR missing critical fields (no prices OR no product names)- Retrieval returns irrelevant products (searching "laptop" returns "headphones")- Prices are hallucinated or inconsistent (not from documents)- Test queries: &lt;2 correct retrievals out of 3- No embeddings (uses keyword matching with .find() or string search only)- Cannot identify Vector Store implementation in code- Responses are incoherent or don't answer questions                                            |
| 1.2 Order Agent - Autonomous Handoff & Database Persistence | - Two distinct agents with clear handoff mechanism: - Agent 1 (RAG/Info Agent): Answers product questions, maintains conversation until order intent detected - Agent 2 (Order Agent): Activates when user confirms order, handles database persistence, provides confirmation- Handoff triggered autonomously by conversation analysis (detects order intent from phrases: "I'll take it", "place order", "buy", "confirm", "yes, please")- Transition is smooth and conversational: "Perfect! Let me process your order for the iPhone 15 Pro..."- Order Agent extracts complete order details from chat history: product_name, quantity, price, customer_info (if provided)- Order successfully persisted to database with all required fields- Database entry includes: unique order_id, product(s), quantity, total_price, timestamp- Test complete flow (5+ turn conversation): Product inquiry > Clarification > Price question > Order confirmation > Database entry created > User receives order_id- Conversational order confirmation: "Your order has been confirmed! Order ID: #ORD-12345. Total: $999. Thank you!" | - Two agents with different responsibilities visible in code- Handoff occurs when user confirms order (basic intent detection works)- Transition happens but may lack polish- Order Agent extracts product name and quantity from conversation- Order saved to database (entry is verifiable)- Database contains minimum: order_id, product, quantity, price- Test flow works: Question > Answer > Confirmation > Database save successful- Basic confirmation message provided to user | - Single agent handles everything OR no clear agent separation in code- Handoff mechanism broken (Agent 2 never activates OR activates at wrong times)- Agent 2 cannot extract order details from chat history (asks user to repeat everything)- No database persistence (order printed to console only OR saved nowhere)- Database missing critical fields (no product name OR no price OR no order_id)- Test flow fails: Order not saved after user confirmation- No order confirmation provided to user OR confirmation contains wrong information- System requires manual intervention to switch between agents |
|                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 2. FUNCTION CALLING & AUTONOMOUS TOOL ORCHESTRATION         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 2.1 Function Calling Implementation                         | Implements OpenAI Function Calling with ≥2 tools properly defined:- Function schemas include: name, description, parameters with types, required fields- Functions actually execute when called (not just defined)- Function execution returns structured results that agent can use- Agent processes function results and incorporates into conversation naturally- Code shows: API call with tools parameter > check for tool_calls > execute function > send result back to API- Test: Function calling visible in API response (response.choices[0].message.tool_calls exists)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | - Implements Function Calling with 2+ tools defined- Function schemas include name, parameters, basic types- Functions execute and return results- API calls include tools parameter- Function results returned to conversation- Test: Functions are called and execute successfully                                                                                                                                                                                                    | - No Function Calling (uses manual if/else keyword routing instead)- Only 1 tool defined OR tools improperly structured- Function schemas incomplete (missing parameters OR types)- Functions defined but never execute (not connected to API)- Function execution fails with errors (crashes on tool_call)- Cannot verify function calls in code or traces- Uses wrong API method (not chat completions with tools)                                                                                                                                                                                                |
| 2.2 Autonomous Decision-Making & Tool Selection             | - Agent autonomously decides when to call which tool based purely on conversation context (no manual routing)- Test with 8+ diverse scenarios showing intelligent tool selection: - "What's the price of iPhone?" > Calls search_products("iPhone") - Ambiguous: "I want one" without context > Asks clarification instead of calling create_order- Agent correctly passes context-aware parameters: If user discussed "MacBook Pro" and says "I'll take 2", function call includes product="MacBook Pro", quantity=2- Handles tool errors gracefully: Invalid product > "I couldn't find that product. Could you describe it differently?"- No function call loops (doesn't call same function repeatedly without progress)- Agent explains actions conversationally: "Let me search for laptops..." (before tool call)                                                                                                                                                                                                                                                                                                         | - Agent autonomously selects correct tool type for query- Product questions > search_products called- Order confirmations > create_order called- Test with 4+ scenarios: >3 show correct tool selection- Passes basic parameters to functions- Handles at least one error type (try-except around function execution)- Tool decisions mostly correct (may have 1-2 wrong choices)                                                                                                       | - Manual routing (if "price" in query: call search, elif "buy" in query: call create_order)- Agent calls wrong tool for query type (calls create_order for price question)- Random or inconsistent tool selection (same query triggers different tools)- Cannot pass context-aware parameters (doesn't know which product to order)- No error handling (crashes when tool fails)- Function call loops or infinite recursion- Test scenarios:&lt;3 correct tool selections out of 4- Tool calls don't match user intent                                                                                              |
|                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 3. DATA MODELING & PERSISTENCE                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 3.1 Pydantic Models & Structured Validation                 | - Defines comprehensive Pydantic models (e.g. Product, OrderModel, etc)- Uses Field() with constraints: gt/lt for numbers, min_length/max_length for strings, min_items for lists- Custom validators for business logic (total_price calculation, product existence)- Type hints comprehensive: str, int, float, List, Optional, datetime, Enum- All database operations use validated Pydantic models (no raw dicts bypass validation)- Validation errors caught and handled gracefully with user-friendly messages                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | - Defines OrderModel (minimum) with Pydantic BaseModel- Includes required fields: product_name, quantity, price- Basic type hints: str, int, float- Uses Field() for at least one constraint (gt=0 for price)- Database operations use Pydantic models for orders- Validation works (model.model_validate() succeeds for valid data)- Catches validation errors (try-except around validation)                                                                                          | - No Pydantic models (uses plain dict:`order = {"product": "iPhone", "qty": 1}`)- Models missing critical fields (no product OR no price OR no quantity)- No type hints or incorrect types (quantity as str instead of int)- No Field constraints (accepts negative prices, zero quantities)- Database operations bypass Pydantic (saves raw dicts or strings)- Validation doesn't work (invalid data passes through)                                                                                                                                                                                             |
| 3.2 Database Implementation & Data Integrity                | - Implements SQL database (SQLite, PostgreSQL, MySQL) OR structured JSON/text database:- Generates unique order IDs (UUID, auto-increment, or timestamp-based with no collisions)- CRUD operations implemented: - Create: Insert new orders - Read: Retrieve order by order_id (for confirmation/status checks)- Database file persists between program runs (data not lost on restart)- Data integrity maintained (no corruption, no overwriting)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | - Database implemented (SQL OR JSON file OR structured text)- Basic schema: stores order_id, product_name, quantity, total_price- Insert operation works (new orders successfully saved)- Read operation works (can retrieve orders by ID)- Unique order IDs generated (no duplicates)- Data persists (file/database exists after program ends)                                                                                                                                         | - No database (only prints orders to console OR stores in non-persistent variable)- Database doesn't persist (data lost on program restart OR file overwritten each time)- Inconsistent schema (orders have different fields or structure)- SQL injection vulnerability (uses string concatenation: f"INSERT INTO orders VALUES ('{order_id}')")- Order IDs not unique (duplicates OR sequential without gaps causing overwrites)- Data corruption (malformed JSON, broken CSV, SQLite database errors)                                                                                                             |
|                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 4. CODE QUALITY & DOCUMENTATION                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 4.1 Code Organization & Structure                           | - Agent classes defined (RAGAgent, OrderAgent) OR well-organized functions with clear agent logic separation- Chat history properly managed in data structure: List[Dict[str, str]] with {"role": "user"/"assistant", "content": "..."} or similar- Clear separation of concerns: RAG retrieval logic > conversation management > order processing > database operations in separate modules/functions- DRY principle: No code duplication (repeated logic extracted to functions)- Logical flow: Imports at top > Constants/config > Helper functions > Agent functions > Main execution at bottom                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | - Agent logic separated (RAG function separate from order function)- Chat history stored in variable (List or similar structure)- Some separation of concerns (database code not mixed with RAG logic)- Type hints on key functions (at least 50% of functions)- Limited duplication (same block repeated ≤2 times)- Basic organization: imports at top, execution at bottom                                                                                                           | - ≤2 functions (monolithic code: everything in main() or single 200+ line function)- No clear agent separation (RAG and order logic intermixed)- No chat history management (only handles single turn, no memory)- Mixed concerns (database INSERT statements inside RAG retrieval function)- Significant duplication (same 5+ line block repeated 3+ times)- Poor function names: func1(), func2(), process(), do_thing(), handle()                                                                                                                                                                               |
| 4.2 Documentation - README & Comments                       | README includes comprehensive sections: - Project Description (100+ words): Explains delivery chatbot functionality, two-agent architecture, autonomous tool orchestration- Architecture Diagram: Visual or text diagram- Product Data Management (50+ words): How to add/update products in Vector Store, expected format, example product entry- Database Schema (50+ words): Shows table structure OR JSON format with field descriptions and types- Technical Decisions: Why RAG for products? Why Function Calling? Why two agents instead of one? How does handoff work?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | README with some sections like:- Project description (50+ words explaining what it does)- Setup instructions with API key configuration and how to run- Database schema mentioned (table/file structure described)- Architecture explained (mentions two agents)- Some docstrings (≥3 functions documented)                                                                                                                                                                            | - No README OR under 50 words- Missing setup steps or API key info- No architecture explanation- No usage examples- No agent descriptions- Under 2 comments total, no docstrings- Cannot run by following instructions                                                                                                                                                                                                                                                                                                                                                                                              |
| 4.3 Dependencies & Best Practices                           | - All keys from environment: os.getenv("OPENAI_API_KEY"), no "sk-" in code- Settings in config file or environment (not hardcoded)- 3+ try-except blocks for API calls and errors- 3+ functions have type hints, follows style guide, no security issues                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | - Keys from environment (no hardcoded "sk-" or "pk-lf-")- Settings at top of file- 2+ try-except blocks- Generally readable code                                                                                                                                                                                                                                                                                                                                                        | - Hardcoded keys visible: "sk-proj-xxx"- Numbers and settings throughout code- 0-1 try-except blocks, crashes easily- Uses eval(), messy imports, security issues                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
