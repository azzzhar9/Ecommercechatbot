# Option 3

# Context & Objectives

You are an AI engineer at an innovative technology company tasked with developing a proof-of-concept for a next-generation intelligent system. Leadership has identified a complex business problem that cannot be effectively solved with traditional single-model approaches or simple API integrations. The problem requires multiple specialized AI agents working collaboratively, each handling distinct aspects of the workflow to deliver high-value outcomes to end users.
The executive team needs to see a working prototype that demonstrates: (1) technical feasibility of multi-agent coordination, (2) measurable value creation for target users, (3) integration of cutting-edge AI technologies, and (4) production-ready engineering practices. Your deliverable will inform a decision on whether to greenlight full product development.

## Objectives (what you will deliver and why it matters):

1. Design an original solution to a real user problem that requires multi-agent collaboration. Define clear problem statement, target users, success criteria, and value proposition. This demonstrates product thinking and ensures technical work serves user needs.
2. Implement a functional multi-agent system with at least two specialized agents that have distinct roles and collaborate to produce high-quality output. This proves you can architect complex AI systems where specialization and coordination create value beyond single-agent approaches.
3. Integrate minimum two advanced technologies from the approved stack (LangChain, Vector Store, multi-modal AI, Pydantic, DSPy, Langfuse, task delegation, etc.) in substantive ways that enhance system capability. This shows you can leverage state-of-the-art tools to build sophisticated solutions.
4. Handle simple or multi-modal input (text, images, audio, structured data) with proper validation, preprocessing, and error handling. This ensures robustness for real-world usage with diverse user inputs.
5. Deliver production-quality code with modular architecture, comprehensive documentation, dependency management, and best practices (environment configs, error handling, security). This demonstrates you can ship maintainable systems, not just demos.
6. Document technical decisions and architecture explaining why you chose specific agents, technologies, collaboration patterns, and design tradeoffs. This proves engineering judgment beyond implementation skills.

**Why this matters:** Multi-agent systems represent the frontier of LLM application development. Simple single-prompt solutions cannot handle complex workflows requiring specialization, validation, and iterative refinement. This capstone synthesizes your entire learning journey (M1-M4): prompt engineering, RAG, multi-agent orchestration, and advanced technologies. Mastering open-ended system design with real user value, proper architecture, technology integration, and production practices prepares you to lead AI engineering initiatives in enterprise environments.

# Assignment

Define a project that is based on a simple or multi-modal input and requires at least two collaborating agents to generate a highly valuable output designed to assist users. Ensure the project incorporates a minimum of two technologies or tools from the following list: LangChain, a Vector Store, Image-to-Text, Text-to-Image, Audio-to-Text, Text-to-Audio, Pydantic, DSPy, Langfuse, task delegation, or any other state-of-the-art tool or framework.

# Project Deliverables and Submission Requirements

Submit via a public Git repository link of the repository. Ensure the repository is self-contained and runnable.

## Expected repository structure:

| Deliverable                        | Filename/Format                                                                           | Minimum Content                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ---------------------------------- | ----------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Project proposal                   | docs/proposal.md OR comprehensive README section                                          | 2-3 pages including: Problem Statement (defining user problem, target audience, pain points), Solution Overview (multi-agent approach, user workflow, value proposition), Use Case Examples (3+ specific scenarios), Success Criteria (5+ measurable outcomes like accuracy, time saved, user satisfaction)                                                                                                                                                                         |
| Main implementation                | src/main.py OR app.py OR organized module structure: src/agents/, src/models/, src/utils/ | Functional end-to-end system. Minimum 2 specialized agents with clear separation of concerns. Clean architecture with 8 or more well-named functions. Type hints throughout.                                                                                                                                                                                                                                                                                                        |
| Agent implementations              | src/agents/agent1.py, src/agents/agent2.py (or equivalent organization)                   | Each specialized agent in separate module/class with: unique system prompt defining role, distinct responsibilities, appropriate tools/functions, clear collaboration interfaces. Agent orchestration logic showing coordination pattern (sequential/hierarchical/iterative).                                                                                                                                                                                                       |
| Data models                        | src/models/ OR Pydantic models in dedicated file                                          | Structured input/output validation with Pydantic models. Field constraints, custom validators, clear schemas. Type safety for data passing between agents.                                                                                                                                                                                                                                                                                                                          |
| Sample inputs                      | examples/ OR test_data/ directory                                                         | Minimum 5 diverse test inputs covering: valid cases (different formats, sizes, complexities), edge cases (ambiguous input, boundary conditions), invalid cases (wrong format, empty input). Expected outputs documented.                                                                                                                                                                                                                                                            |
| README                             | README.md                                                                                 | Project Overview (problem, solution, value, users - 200+ words), Architecture Diagram (visual of agents/data flow/technologies), Agent Descriptions (role of each agent - 150+ words), Technology Stack (what & why - 100+ words), Setup Instructions (detailed step-by-step), Usage Guide (input format, commands, examples - 300+ words), Example Use Cases (3+ complete scenarios), Technical Design Decisions (why multi-agent, why these technologies, tradeoffs - 200+ words) |
| Dependencies, Environment template | requirements.txt, .env.example                                                            | Pinned versions for all packages. Minimum dependencies: openai, langchain OR langchain-core, plus 2+ of: chromadb/faiss-cpu/pinecone-client, pydantic, langfuse, pillow, whisper, other technology libraries. Template showing all required environment variables: OPENAI_API_KEY=your-key-here, LANGFUSE_PUBLIC_KEY=pk-lf-xxx (if using), LANGFUSE_SECRET_KEY=sk-lf-xxx, LANGFUSE_HOST=xxx, plus any other service keys needed.                                                    |

---

# Evaluation Rubric

| Criterion                                   | Excellent                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Satisfactory                                                                                                                                                                                                                                                                                                                  | Incomplete/Unsatisfactory                                                                                                                                                                                                                                                                                                                                                             |
| ------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. PROJECT DESIGN & CORE FUNCTIONALITY      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                       |
| 1.1 Project Proposal & Problem Definition   | - Submitted project proposal document (2-3 pages OR detailed README section) including: - Problem Statement (150+ words): Clear description of user problem being solved, target audience, current pain points - Solution Overview (150+ words): How multi-agent system addresses the problem, expected user workflow, value proposition - Use Case Examples (3+ scenarios): Specific situations where system provides value - Success Criteria (5+ measurable outcomes): What makes this solution successful (accuracy metrics, time saved, user satisfaction indicators)- Problem is well-scoped: Not too broad (entire enterprise system) OR too narrow (single calculation)- Solution demonstrates clear value: Saves time, automates complex workflow, provides insights, enhances decision-making, or creates new capabilities- Justifies multi-agent approach: Explains why 2+ agents are necessary (task complexity, specialization, parallel processing) | - Project proposal or design document exists (1+ pages)- Describes problem being solved (100+ words)- Explains solution approach (100+ words)- Provides 2+ use case examples- States success criteria (3+ outcomes)- Problem scope is reasonable- Solution has identifiable value                                             | - No project proposal or design documentation- Problem unclear or too vague ("make something cool with AI")- Solution doesn't address identified problem- No use cases provided- No success criteria defined- Problem too trivial (could be solved with single API call) OR impossibly complex- No clear value proposition (why would users want this?)                               |
| 1.2 System Functionality & User Value       | - System fully functional end-to-end: Accepts input > processes through agents > delivers output- Output is high-quality and valuable: - Solves stated problem effectively - Results are accurate (≥85% accuracy for test cases) - Provides actionable insights, completed artifacts, or automated solutions - Formatted professionally (not raw JSON dumps to user)- Demonstrates measurable value: Saves time (vs manual process), improves accuracy, enables new capability, or provides comprehensive analysis- User interaction is smooth: Clear instructions, helpful feedback, progress indicators for long operations- System handles edge cases: Invalid input > clear error message, ambiguous input > asks clarification                                                                                                                                                                                                                              | - System functional: Input > processing > output works- Handles at least one input type correctly (text OR image OR audio)- Output addresses the stated problem- Results are usable by end user- User can successfully use the system                                                                                         | - User experience is confusing or broken- No demonstrable value (output not better than manual process OR simple single-agent solution)- System doesn't work end-to-end (missing pieces, crashes frequently)- Cannot process stated input type (claims multi-modal but only handles text)- Does not solve the stated problem                                                          |
|                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                       |
| 2. MULTI-AGENT ARCHITECTURE & COLLABORATION |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                       |
| 2.1 Multimodal LLM API Integration          | - ≥2 specialized agents with distinct, well-defined roles: - Each agent has unique responsibility (analyzer, generator, validator, coordinator, retriever, etc.) - Agent system prompts clearly define role, capabilities, and constraints - Agents have appropriate tools/functions for their role- Agent specialization justified in documentation: - Explains why each agent exists - Describes what each agent does better than a single general agent- Agent implementation visible in code: - Separate classes (AnalyzerAgent, GeneratorAgent) OR distinct functions with dedicated prompts - Clear boundaries between agent responsibilities                                                                                                                                                                                                                                                                                                              | - 2+ agents with different responsibilities- Each agent has distinct system prompt- Agent roles identifiable in code (separate functions/classes)- Documentation mentions what each agent does- Test: Both agents perform their tasks- Agents don't completely overlap in function                                            | - Only 1 agent OR "agents" are same with different names- Agents have identical system prompts and logic- No clear role differentiation (both agents do same thing)- Cannot identify separate agents in code- No documentation of agent purposes- Test: Cannot determine which agent did what- Agents are redundant (system would work same with single agent)                        |
| 2.3 Agent Collaboration & Orchestration     | - Clear collaboration pattern implemented (choose one or combine): - Sequential Pipeline: Agent 1 > Agent 2 > Agent 3 (each builds on previous) - Hierarchical: Orchestrator agent delegates to specialized sub-agents- Data flow between agents is explicit and traceable: - Agent 1 output > Agent 2 input (visible in code) - Handoff mechanism clear (function calls, message passing, shared state)- Uses task delegation framework (if applicable): LangChain agents, OpenAI function calling, custom orchestration- Documentation explains: Collaboration pattern chosen, why this pattern fits the problem, how agents communicate                                                                                                                                                                                                                                                                                                                        | - Collaboration pattern identifiable (sequential OR hierarchical OR iterative)- Agent 2 receives Agent 1's output- Data flow visible in code (passing variables/results)- Coordination works (agents execute in correct sequence)- Test: Workflow completes, agents work together- Basic documentation of how agents interact | - No clear collaboration pattern (agents independent)- Agent 2 doesn't use Agent 1's results (redoes all work from scratch)- No visible data flow (cannot trace how information moves)- Coordination broken (wrong agent activates OR agents run in wrong order)- Test fails: Agents don't collaborate, workflow incomplete- No explanation of collaboration approach                 |
|                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                       |
| 3. TECHNOLOGY INTEGRATION & IMPLEMENTATION  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                       |
| 3.1 Required Technology Integration         | - Integrates ≥2 technologies from required list (or approved alternatives): - LangChain: Uses chains, agents, retrievers (not just ChatOpenAI wrapper) - Vector Store: Chroma, FAISS, Pinecone with embeddings and retrieval - Image-to-Text: GPT-4o Vision, Gemini Vision, Claude 3 with images - Text-to-Image: DALL-E, Midjourney, Stable Diffusion - Audio-to-Text: Whisper API, AssemblyAI - Text-to-Audio: OpenAI TTS, ElevenLabs - Pydantic: Structured validation with Field constraints and validators - DSPy: Optimization with LM modules and assertions - Langfuse: Tracing with spans, metadata, performance tracking - Task Delegation: OpenAI function calling, LangChain tools, agent orchestration- Technologies integrated coherently (work together, not bolted on)                                                                                                                                                                           | - Uses 2+ technologies from required list- Each technology has visible implementation in code- Technologies function correctly (basic usage works)- Some integration between technologies- Test: Both technologies execute successfully                                                                                       | - Uses <2 required technologies- Technologies mentioned but not implemented (imports exist but never used)- Superficial usage (trivial wrappers that don't leverage technology capabilities)- Technologies don't work (API calls fail, libraries not configured)- No integration (technologies used independently with no connection)- Test: One or both technologies fail to execute |
| 3.2 Technical Implementation Quality        | - API usage follows best practices: - Proper authentication (keys from environment) - Error handling for API failures (rate limits, timeouts, invalid requests) - Retry logic with exponential backoff for transient failures - Appropriate parameters (temperature, max_tokens, model selection justified)- Async/await used for concurrent operations (if applicable)- Resource management: Files closed, connections pooled, memory efficient- Performance optimizations: - Caching responses when appropriate - Batching requests to reduce API calls - Streaming for long outputs (if applicable)                                                                                                                                                                                                                                                                                                                                                            | - API calls work correctly- Basic error handling (try-except around calls)- Keys from environment (not hardcoded)- Appropriate parameters set- Resources generally managed well- Test: Handles at least one error scenario                                                                                                    | - APIs called incorrectly (wrong methods, missing parameters)- No error handling (crashes on first API error)- Hardcoded API keys (security issue)- Poor resource management (memory leaks, file handles left open)- No performance consideration (unnecessary repeated calls)- Cannot handle common edge cases                                                                       |
|                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                       |
| 4. CODE QUALITY & DOCUMENTATION             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                       |
| 4.1 Code Organization & Structure           | - Modular project structure with logical separation:- Clear separation of concerns: - Agent logic separate from API clients - Data models in dedicated files - Utilities and helpers organized- 8 or so well-named functions with single responsibility- DRY principle: No code duplication- Design patterns applied appropriately (Factory, Strategy, Template Method if suitable)- Configuration management: All settings in config file or environment                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | - 2+ files with logical organization (agents separate from main)- ≥5 functions with clear names- Some type hints (50%+ of functions)- Limited duplication (≤2 instances)- Basic configuration management- Imports organized at top of files                                                                                 | - Single monolithic file with all code- ≤3 functions (everything in main)- No type hints- Significant code duplication (3+ instances of same logic)- Poor function names (func1, process, handle)- Mixed concerns (database, API, business logic all intertwined)- No configuration management (hardcoded values throughout)                                                         |
| 4.2 Documentation & User Guide              | - Comprehensive README with all sections: - Project Overview: Problem, solution, value proposition, target users - Architecture Diagram: Visual showing agents, data flow, technologies used - Agent Descriptions (150+ words): What each agent does, why specialized, how they collaborate - Technology Stack: Lists all technologies, justifies choices, explains integration - Setup Instructions (detailed steps): - Usage Guide (300+ words): Input format, example commands, expected workflow, sample outputs - Technical Design Decisions (200+ words): Why multi-agent? Why these technologies? Architecture tradeoffs?- Code documentation: - Inline comments for complex logic (≥10 meaningful comments) - Comments explain "why" not "what"                                                                                                                                                                                                          | README with sections:- Project overview and problem explanation- Setup instructions (can follow to run project)- Usage examples (2+ scenarios)- Technology stack listed- Agent descriptions (what each does)- Some docstrings (≥5 functions documented)- Some inline comments (≥5 comments)                                 | - No README OR <300 words total- Missing setup instructions (cannot run project)- No usage examples- Technologies not documented- Agents not explained (unclear what system does)- No docstrings- No or minimal comments (<3 total)- Cannot understand system without reading all code                                                                                                |
| 4.3 Dependencies & Best Practices           | - requirements.txt with pinned versions for all dependencies- .env.example showing all required environment variables- .gitignore comprehensive (secrets, cache, data files, virtual environments)- Error handling comprehensive: - try-except for API calls with specific exception types - Validation errors caught with user-friendly messages - Logging configured (info, warning, error levels)- Security best practices: - No secrets in code or git - Input sanitization (prevents injection attacks) - File upload size limits enforced                                                                                                                                                                                                                                                                                                                                                                                                                   | - requirements.txt with main dependencies- API keys from environment (not hardcoded)- .gitignore includes .env and pycache- Basic error handling (≥3 try-except blocks)- README mentions environment setup- Sample inputs provided or described                                                                              | - No requirements.txt OR missing critical dependencies- Hardcoded secrets (CRITICAL SECURITY ISSUE)- No .gitignore OR secrets committed to git- No error handling (crashes on first error)- No sample inputs (cannot test without creating own)- Cannot run project following documentation                                                                                           |
